import * as postcss from "postcss";
import * as fs from "fs";
import * as path from "path";
import { assert } from "chai";
import { suite, test, only, skip } from "mocha-typescript";

import cssBlocks = require("../../src/cssBlocks");
import { PluginOptions, } from "../../src/options";
import { OptionsReader, } from "../../src/options";
import { BlockFactory } from "../../src/Block/BlockFactory";
import { MockImportRegistry } from "../util/MockImportRegistry";
import minify from "../util/minify";

function fileEqual(filename: string, content: string) {
  return assert.equal(minify(fs.readFileSync(filename, 'utf8')), minify(content));
}

@suite("Typescript Definitions Formatter")
export class TypescriptDefitionsTest {

  @test "generates typescrit definition for root"() {
    let imports = new MockImportRegistry();

    let filename = "foo/bar/block.css";
    let defFilename = path.join(process.cwd(), '.cssblocks', filename + '.d.ts');

    imports.registerSource(filename, `
       .root { color: red; }
    `);
    let importer = imports.importer();
    let reader = new OptionsReader({
      generateTypes: cssBlocks.TypesMode.TYPESCRIPT,
      importer: importer
    });

    let factory = new BlockFactory(reader, postcss);
    let blockPromise = factory.getBlock(importer.identifier(null, filename, reader));

    return Promise.all([ blockPromise ]).then(() => {
      fileEqual(defFilename, `
        /*****************************************************/
        /*    Autogenerated by CSS Blocks. DO NOT MODIFY.    */
        /*****************************************************/

        declare type Style = { [str: string]: boolean } & symbol;

        declare class Block {
          readonly root: Style;
        }

        declare let out: Block & Style;

        export default out;
      `);
      factory.reset();

    });
  }

  @test "type generation path is customizable"() {
    let imports = new MockImportRegistry();

    let filename = "foo/bar/block.css";
    let defFilename = path.join(process.cwd(), '.cssblocks-tmp', filename + '.d.ts');

    imports.registerSource(filename, `
       .root { color: red; }
    `);
    let importer = imports.importer();
    let reader = new OptionsReader({
      generateTypes: cssBlocks.TypesMode.TYPESCRIPT,
      typesPath: '.cssblocks-tmp',
      importer: importer
    });

    let factory = new BlockFactory(reader, postcss);
    let blockPromise = factory.getBlock(importer.identifier(null, filename, reader));

    return Promise.all([ blockPromise ]).then(() => {
      fileEqual(defFilename, `
        /*****************************************************/
        /*    Autogenerated by CSS Blocks. DO NOT MODIFY.    */
        /*****************************************************/

        declare type Style = { [str: string]: boolean } & symbol;

        declare class Block {
          readonly root: Style;
        }

        declare let out: Block & Style;

        export default out;
      `);

      factory.reset();
    });
  }

  @test "block factory cleans up after itself"() {
    let imports = new MockImportRegistry();

    let filename = "foo/bar/block.css";
    let defFilename = path.join(process.cwd(), '.cssblocks', filename + '.d.ts');

    imports.registerSource(filename, `
       .root { color: red; }
    `);
    let importer = imports.importer();
    let reader = new OptionsReader({
      generateTypes: cssBlocks.TypesMode.TYPESCRIPT,
      importer: importer
    });

    let factory = new BlockFactory(reader, postcss);
    let blockPromise = factory.getBlock(importer.identifier(null, filename, reader));

    return Promise.all([ blockPromise ]).then(() => {
      assert.ok(fs.existsSync(defFilename));
      factory.reset();
      assert.notOk(fs.existsSync(defFilename));
    });
  }

  @test "generates typescrit definition for classes"() {
    let imports = new MockImportRegistry();

    let filename = "foo/bar/block.css";
    let defFilename = path.join(process.cwd(), '.cssblocks', filename + '.d.ts');

    imports.registerSource(filename, `
       .root { color: red; }
       .foo { color: blue; }
    `);
    let importer = imports.importer();
    let reader = new OptionsReader({
      generateTypes: cssBlocks.TypesMode.TYPESCRIPT,
      importer: importer
    });

    let factory = new BlockFactory(reader, postcss);
    let blockPromise = factory.getBlock(importer.identifier(null, filename, reader));

    return Promise.all([ blockPromise ]).then(() => {
      fileEqual(defFilename, `
        /*****************************************************/
        /*    Autogenerated by CSS Blocks. DO NOT MODIFY.    */
        /*****************************************************/

        declare type Style = { [str: string]: boolean } & symbol;

        declare class Block {
          readonly foo: Style;
          readonly root: Style;
        }

        declare let out: Block & Style;

        export default out;
      `);

      factory.reset();
    });
  }

  @test "generates typescrit definition for states"() {
    let imports = new MockImportRegistry();

    let filename = "foo/bar/block.css";
    let defFilename = path.join(process.cwd(), '.cssblocks', filename + '.d.ts');

    imports.registerSource(filename, `
       .root { color: red; }
       [state|biz=baz] { color: red;}
       .foo { color: red; }
       .foo[state|bar] { color: red;}
       .foo[state|biz=baz] { color: red;}
    `);
    let importer = imports.importer();
    let reader = new OptionsReader({
      generateTypes: cssBlocks.TypesMode.TYPESCRIPT,
      importer: importer
    });

    let factory = new BlockFactory(reader, postcss);
    let blockPromise = factory.getBlock(importer.identifier(null, filename, reader));

    return Promise.all([ blockPromise ]).then(() => {
      fileEqual(defFilename, `
        /*****************************************************/
        /*    Autogenerated by CSS Blocks. DO NOT MODIFY.    */
        /*****************************************************/

        declare type Style = { [str: string]: boolean } & symbol;

        declare class FooClass {
          bar(enabled?: any): Style;
          biz(substate: "baz"): Style;
          biz(substate: string | number | boolean): Style;
        }

        declare class Block {
          readonly foo: FooClass & Style;
          readonly root: Style;
          biz(substate: "baz"): Style;
          biz(substate: string | number | boolean): Style;
        }

        declare let out: Block & Style;

        export default out;
      `);

      factory.reset();
    });
  }

  @test "generates typescrit definition for conflicting class and state names"() {
    let imports = new MockImportRegistry();

    let filename = "foo/bar/block.css";
    let defFilename = path.join(process.cwd(), '.cssblocks', filename + '.d.ts');

    imports.registerSource(filename, `
       .root { color: red; }
       .foo { color: red; }
       .foo[state|foo] { color: red; }
       [state|foo] { color: red;}
    `);
    let importer = imports.importer();
    let reader = new OptionsReader({
      generateTypes: cssBlocks.TypesMode.TYPESCRIPT,
      importer: importer
    });

    let factory = new BlockFactory(reader, postcss);
    let blockPromise = factory.getBlock(importer.identifier(null, filename, reader));

    return Promise.all([ blockPromise ]).then(() => {
      fileEqual(defFilename, `
        /*****************************************************/
        /*    Autogenerated by CSS Blocks. DO NOT MODIFY.    */
        /*****************************************************/

        declare type Style = { [str: string]: boolean } & symbol;

        declare class FooClass {
          foo(enabled?: any): Style;
        }

        interface FooState {
          (enabled?: any): Style;
        }

        declare class Block {
          readonly foo: FooClass & FooState & Style;
          readonly root: Style;
        }

        declare let out: Block & Style;

        export default out;
      `);

      factory.reset();
    });
  }

  @test "generates typescrit definitions for extended blocks"() {
    let imports = new MockImportRegistry();
    let baseFilename = "foo/bar/base.css";
    let baseDefFilename = path.join(process.cwd(), '.cssblocks', baseFilename + '.d.ts');
    imports.registerSource(baseFilename,
      `.root { color: purple; }
       [state|large] { font-size: 20px; }
       [state|color=red] { color: red; }
       .foo   { float: left;   }
       .foo[state|small] { font-size: 5px; }
       .foo[state|color=yellow] { color: yellow; }
       .foo[state|color=orange] { color: yellow; }
    `);

    let extendsFilename = "foo/bar/extends.css";
    let extendsDefFilename = path.join(process.cwd(), '.cssblocks', extendsFilename + '.d.ts');
    imports.registerSource(extendsFilename,
      `@block-reference base from "./base.css";
       .root { extends: base; color: red; }
       [state|color=blue] { color: blue; }
       [state|small] { font-size: 5px; }
       .foo[state|medium] { font-size: 10px; }
       .foo[state|color=green] { color: green; }
       .foo[state|color=orange] { color: yellow; }
    `);
    let importer = imports.importer();
    let reader = new OptionsReader({
      generateTypes: cssBlocks.TypesMode.TYPESCRIPT,
      importer: importer
    });
    let factory = new BlockFactory(reader, postcss);
    let extendsBlockPromise = factory.getBlock(importer.identifier(null, extendsFilename, reader));
    let baseBlockPromise = factory.getBlock(importer.identifier(null, baseFilename, reader));
    return Promise.all([extendsBlockPromise, baseBlockPromise]).then(() => {
      console.log(fs.readFileSync(baseDefFilename, 'utf8'));
      fileEqual(baseDefFilename, `
        /*****************************************************/
        /*    Autogenerated by CSS Blocks. DO NOT MODIFY.    */
        /*****************************************************/

        declare type Style = { [str: string]: boolean } & symbol;

        declare class FooClass {
          color(substate: "yellow" | "orange"): Style;
          color(substate: string | number | boolean): Style;
          small(enabled?: any): Style;
        }

        declare class Block {
          readonly foo: FooClass & Style;
          readonly root: Style;
          color(substate: "red"): Style;
          color(substate: string | number | boolean): Style;
          large(enabled?: any): Style;
        }

        declare let out: Block & Style;

        export default out;
      `);

      fileEqual(extendsDefFilename, `
        /*****************************************************/
        /*    Autogenerated by CSS Blocks. DO NOT MODIFY.    */
        /*****************************************************/

        declare type Style = { [str: string]: boolean } & symbol;

        declare class FooClass {
          color(substate: "green" | "orange" | "yellow"): Style;
          color(substate: string | number | boolean): Style;
          medium(enabled?: any): Style;
          small(enabled?: any): Style;
        }

        declare class Block {
          readonly foo: FooClass & Style;
          readonly root: Style;
          color(substate: "blue" | "red"): Style;
          color(substate: string | number | boolean): Style;
          large(enabled?: any): Style;
          small(enabled?: any): Style;
        }

        declare let out: Block & Style;

        export default out;
      `);

      factory.reset();

    });
  }

}
